% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage{float}
\usepackage{mathtools}

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or.... 
%\geometry{margin=1in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
%\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{caption}
\usepackage{subcaption}

\DeclareCaptionFormat{subfig}{\figurename~#1#2#3}
\DeclareCaptionSubType*{figure}
\captionsetup[subfigure]{format=subfig,labelsep=colon,labelformat=simple}


%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
%\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help) % (This matches ConTeXt defaults)
%%% ToC (table of contents) APPEARANCE
%\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!


\usepackage{listings}
\usepackage{color}
\usepackage{microtype}
\usepackage{hyperref} % use hyperlinked ToC
\hypersetup{colorlinks=true, linkcolor=black}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.6,0,0.6}

\lstset{frame=tb,
  %language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{mauve},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}
%%% END Article customizations
%%% The "real" document content comes below...
\title{RTDSP Project: Speech Enhancement}
\author{Joshua Elsdon je310, Oskar Weigl ow610}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle
\center{\textbf{\large{\emph{...a profound trust in the advancement of science.}	}}}
\abstract{
Talk about the high level conclusions of the project including the fact our stuff is super quick and any numeric metrics that show noise reduction. }
\tableofcontents
\clearpage
\begin{raggedright}




\section{Introduction} 
In this project we aim to produce a real time filtering algorithm that will remove a variety noise sources from a sample recording. The filtering operation needs to be effective on all noise sources without noise specific modifications. The basic form for all these filters will be to find the background noise signature then to subtract that from the recording, this is known as \emph{Spectral Subtraction}. 

\section{Simple Implementation of Spectral Subtraction} 
\label{sec:simple}
In this implementation we track the noise in the sample by taking the minimum amplitude of each bin of FFT. We continually update this during a 2.5s period, after this we save this into an array for future reference, and be start on a new period of 2.5s. We hold 4 examples of the noise floor (including the current one). For each bin we select the minimum value from each of these examples to make the current noise floor, then we subtract the spectrum from the input spectrum. After each 2.5 second period we shift the noise floor examples along, deleting the last one to maintain exactly 4 examples of the noise floor. The code that achieves this can be seen in Appendix~\ref{app:simple}. This implementation has two tuning parameters, Alpha and Lambda. Alpha controls the amplification factor that is applied to the model noise floor before subtraction, very low values give insufficient noise attenuation, very high values start to distort the speech making it sound somewhat like the speaker is underwater. A value of between 2 and 10 makes for the most audible speech, varying depending on the source of noise present. 
Lambda is the value setting the minimum value that the noise floor is allowed to take, as on a occasion the noise floor could be considered negative (and hence we would actually add more noise upon subtraction), this should be kept low, in fact we found that a value of 0 works the best, this just ensures that the noise floor cannot be considered negative though all positive values will pass through unchanged.  

\section{Enhancement 1: Low pass filtering $\lvert X(\omega) \rvert $} 
\begin{figure}[htbp]
	\begin{center}
    \begin{lstlisting}[language = C]
for (k = 0; k < FFTLEN; ++k)
	{
		float curramp = cabs(procframe[k]); 

		curramp = (1-kop1)*curramp + kop1*ampbinstate[k];
		ampbinstate[k] = curramp;

		float currnoisebin = clearM ? curramp : min(Mbuffs[0][k], curramp);
		Mbuffs[0][k] = currnoisebin;

		for (i = 1; i < NumMbuff; ++i)
			currnoisebin = min(currnoisebin, Mbuffs[i][k]);

		currnoisebin *= alpha;

		float g = max(lambda, 1-(currnoisebin/curramp));
		procframe[k] = rmul(g, procframe[k]);
	}
    \end{lstlisting}
  \end{center}
	\caption{Code segment showing the implementation of low pass filtering the FFT of the input}
	\label{code:LPFxOMG}
\end{figure}

This enhancement tries to combat the inaccuracies of taking the minimum value of each bin to represent the noise floor. This problem manifests because often the minimum for each bin is not representative of the actual noise floor, hence the need for large alpha values at times. By using a low pass filter, one off low values in a particular bin are given less influence on the current noise floor model, and they will need to remain low for a number of windows to suggest that that particular bin is indeed required to be lower to be representative of the noise floor. This filtering is applied directly to the FFT of the input and there for the current method of finding the minimum value for each bin can be maintained. The low pass filtering code segment is shown in Figure~\ref{code:LPFxOMG}.  Line number \verb"5" performs the FIR filter within the for loop that is incrementing \verb"k", the loop is also performing other operations not relevant to the FIR filtering. 

The effect of this enhancement is very noticeable, the words are less corrupted by the subtraction of the noise, due the fact that our estimation of the noise is much more representative of the actual noise floor.   



\end{raggedright}

\section{APPENDIX} 
\appendix
\section{Simple Implementation} 
\label{app:simple}

This is the standard implementation as described in Section~\ref{sec:simple}. No special modifications have been made. 
  \begin{center}
    \begin{lstlisting}[language = C]
fft(FFTLEN, procframe);
									
    static int MRotate_ctr = 0;

	if (MRotate_ctr == MrotateFramecount){

		MRotate_ctr = 0;

		//rotate Mbuffs
		float* rottemp = Mbuffs[NumMbuff-1];
		for (i = NumMbuff-1; i != 0; --i)
			Mbuffs[i] = Mbuffs[i-1];
		Mbuffs[0] = rottemp;

		//Init new mbuff
		clearM = 1;
	} else {
		MRotate_ctr++;
		clearM = 0;
	}

	for (k = 0; k < FFTLEN; ++k)
	{
		float curramp = cabs(procframe[k]); 
		float currnoisebin = Mbuffs[0][k] = clearM ? curramp : min(Mbuffs[0][k], curramp);
		for (i = 1; i < NumMbuff; ++i)
			currnoisebin = min(currnoisebin, Mbuffs[i][k]);

		currnoisebin *= alpha;

		float g = max(lambda, 1-(currnoisebin/curramp));
		procframe[k] = rmul(g, procframe[k]);
	}

	
	ifft(FFTLEN, procframe);


fft(FFTLEN, procframe);
									
    static int MRotate_ctr = 0;

	if (MRotate_ctr == MrotateFramecount){

		MRotate_ctr = 0;

		//rotate Mbuffs
		float* rottemp = Mbuffs[NumMbuff-1];
		for (i = NumMbuff-1; i != 0; --i)
			Mbuffs[i] = Mbuffs[i-1];
		Mbuffs[0] = rottemp;

		//Init new mbuff
		clearM = 1;
	} else {
		MRotate_ctr++;
		clearM = 0;
	}

	for (k = 0; k < FFTLEN; ++k)
	{
		float curramp = cabs(procframe[k]); 

		//LPF curramp
		curramp = (1-kop1)*curramp + kop1*ampbinstate[k];
		ampbinstate[k] = curramp;

		float currnoisebin = clearM ? curramp : min(Mbuffs[0][k], curramp);
		Mbuffs[0][k] = currnoisebin;

		for (i = 1; i < NumMbuff; ++i)
			currnoisebin = min(currnoisebin, Mbuffs[i][k]);

		currnoisebin *= alpha;

		float g = max(lambda, 1-(currnoisebin/curramp));
		procframe[k] = rmul(g, procframe[k]);
	}

	
	ifft(FFTLEN, procframe);
    \end{lstlisting}
  \end{center}



\end{document}