% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage{float}
\usepackage{mathtools}
\usepackage{microtype}

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or.... 
%\geometry{margin=1in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
%\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{caption}
\usepackage{subcaption}

\DeclareCaptionFormat{subfig}{\figurename~#1#2#3}
\DeclareCaptionSubType*{figure}
\captionsetup[subfigure]{format=subfig,labelsep=colon,labelformat=simple}


%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
%\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help) % (This matches ConTeXt defaults)
%%% ToC (table of contents) APPEARANCE
%\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!


\usepackage{listings}
\usepackage{color}
\usepackage{microtype}
\usepackage{hyperref} % use hyperlinked ToC
\hypersetup{colorlinks=true, linkcolor=black}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.6,0,0.6}

\lstset{frame=tb,
  %language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{mauve},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}
%%% END Article customizations
%%% The "real" document content comes below...
\title{RTDSP Project: Speech Enhancement}
\author{Joshua Elsdon je310, Oskar Weigl ow610}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle
\center{\textbf{\large{\emph{"...a profound trust in the advancement of science."}	}}}

\abstract{
Talk about the high level conclusions of the project including the fact our stuff is super quick and any numeric metrics that show noise reduction. }
\tableofcontents
\clearpage




\section{Introduction} 
In this project we aim to produce a real time filtering algorithm that will remove a variety noise sources from a sample recording. The filtering operation needs to be effective on all noise sources without noise specific modifications. The basic form for all these filters will be to find the background noise signature then to subtract that from the recording, this is known as \emph{Spectral Subtraction}. 

\section{Simple Implementation of Spectral Subtraction} 
\label{sec:simple}
In this implementation we track the noise in the sample by taking the minimum amplitude of each bin of FFT. We continually update this during a 2.5s period, after this we save this into an array for future reference, and be start on a new period of 2.5s. We hold 4 examples of the noise floor (including the current one). For each bin we select the minimum value from each of these examples to make the current noise floor, then we subtract the spectrum from the input spectrum. After each 2.5 second period we shift the noise floor examples along, deleting the last one to maintain exactly 4 examples of the noise floor. The code that achieves this can be seen in Appendix~\ref{app:simple}. This implementation has two tuning parameters, Alpha and Lambda. Alpha controls the amplification factor that is applied to the model noise floor before subtraction, very low values give insufficient noise attenuation, very high values start to distort the speech making it sound somewhat like the speaker is underwater. A value of between 2 and 10 makes for the most audible speech, varying depending on the source of noise present. 
Lambda is the value setting the minimum value that the noise floor is allowed to take, as on a occasion the noise floor could be considered negative (and hence we would actually add more noise upon subtraction), this should be kept low, in fact we found that a value of 0 works the best, this just ensures that the noise floor cannot be considered negative though all positive values will pass through unchanged.  

\section{Low pass filtering $\lvert X(\omega) \rvert $} 
\label{sec:IIRamp}
\begin{figure}[htbp]
	\begin{center}
    \begin{lstlisting}[language = C]
for (k = 0; k < FFTLEN; ++k)
	{
		float curramp = cabs(procframe[k]); 

		curramp = (1-kop1)*curramp + kop1*ampbinstate[k];
		ampbinstate[k] = curramp;

		float currnoisebin = clearM ? curramp : min(Mbuffs[0][k], curramp);
		Mbuffs[0][k] = currnoisebin;

		for (i = 1; i < NumMbuff; ++i)
			currnoisebin = min(currnoisebin, Mbuffs[i][k]);

		currnoisebin *= alpha;

		float g = max(lambda, 1-(currnoisebin/curramp));
		procframe[k] = rmul(g, procframe[k]);
	}
    \end{lstlisting}
  \end{center}
	\caption{Code segment showing the implementation of low pass filtering the FFT of the input}
	\label{code:LPFxOMG}
\end{figure}

This enhancement tries to combat the inaccuracies of taking the minimum value of each bin to represent the noise floor. This problem manifests because often the minimum for each bin is not representative of the actual noise floor, hence the need for large alpha values at times. By using a low pass filter, one off low values in a particular bin are given less influence on the current noise floor model, and they will need to remain low for a number of windows to suggest that that particular bin is indeed required to be lower to be representative of the noise floor. This filtering is applied directly to the FFT of the input and there for the current method of finding the minimum value for each bin can be maintained. The low pass filtering code segment is shown in Figure~\ref{code:LPFxOMG}.  Line number \verb"5" performs the IIR filter within the for loop that is incrementing \verb"k", the loop is also performing other operations not relevant to the IIR filtering. 

The effect of this enhancement is very noticeable, the words are less corrupted by the subtraction of the noise, due the fact that our estimation of the noise is much more representative of the actual noise floor.   
\section{Filtering Using Spectral Power} 
\subsection{Low pass filtering $\lvert X(\omega) \rvert^{2} $} 

This enhancement is very similar to that presented in Section~\ref{sec:IIRamp} though instead of using the amplitude, then IIR filtering it, we IIR filter the power spectrum instead, this is a benefit as it makes a larger difference between quieter background noise, and the louder signal we are trying to extract. This should enhance our ability to extract the noise floor. 

In reality this enhancement added little to the sound quality of the output, bordering on inaudible changes. Though the method of filtering in the power domain will be used to great effect later in the string of enhancements.  

\subsection{Generating $g(\omega)$ Using Ratios of Power} 

\begin{equation}
\label{equ:powerRat}
	g(\omega) = \max\left(\lambda, \sqrt{1- \frac{\lvert N(\omega) \rvert ^{2}}{\lvert X(\omega) \rvert ^{2}}}\right)
\end{equation}

This enhancement generates $g(\omega)$ using the ration of power rather than of amplitude(Equation~\ref{equ:powerRat}), where $g(\omega)$ is the current filter that is to be applied to the input. This has makes the $g(\omega)$ emphasise sounds with larger amplitude much more than those with small amplitude, if we assume that the signal amplitude is always significantly more than that of the noise, then this helps the selectivity of the filter quite significantly. 

This aided the performance of our system, though once again the affect was marginal. The strange sounds that were present in the low frequencies (especially in the car sample) where somewhat reduced, though the actual clarity of the speech was not affected greatly.

\section{Zeroing Bins That Fall Bellow Threshold SNR} 

In this enhancement we wished to remove the small chirping noises that are left over in from the previous enhancements. Generally the chirping is much quieter that the speech after the techniques discussed previously, so we implemented a simple routine that drives bins that have insufficient amplitude, which has been defined by a threshold. 

This has the effect of making the sections with no speech completely silent, so long as there is no musical noise. This is because after previous filtering, all bins fall below our threshold and can be removed completely. Musical noise still gets through this filter in general as it has not been suppressed sufficiently from the previous stages of enhancement. Furthermore, noise that is present during speech is not affected much, as the large amplitude signal adds to the noise and as such the noise can be carried through the threshold check. 

A further improvement to this enhancement was to weight the threshold by the low pass filtered noise power (over all frequencies), such that when there is a large amount of noise the cut will be less aggressive. This is needed because when the noise is loud it is comparable to the signal, so if we cut just above the noise floor, we also cut some of the signal, this makes the speech harder to understand. It is in-fact better to leave a little bit of noise in this situation. When the noise power is low we can assume that the signal will dominate over the noise, and any bins that fall close to the noise floor can be removed without affecting the voice quality.  


\clearpage

\section{APPENDIX}
\renewcommand{\thesubsection}{\Alph{subsection}}
\subsection{Simple Implementation} 
\label{app:simple}

This is the standard implementation as described in Section~\ref{sec:simple}. No special modifications have been made. 
  \begin{center}
    \begin{lstlisting}[language = C]
fft(FFTLEN, procframe);
									
    static int MRotate_ctr = 0;

	if (MRotate_ctr == MrotateFramecount){

		MRotate_ctr = 0;

		//rotate Mbuffs
		float* rottemp = Mbuffs[NumMbuff-1];
		for (i = NumMbuff-1; i != 0; --i)
			Mbuffs[i] = Mbuffs[i-1];
		Mbuffs[0] = rottemp;

		//Init new mbuff
		clearM = 1;
	} else {
		MRotate_ctr++;
		clearM = 0;
	}

	for (k = 0; k < FFTLEN; ++k)
	{
		float curramp = cabs(procframe[k]); 
		float currnoisebin = Mbuffs[0][k] = clearM ? curramp : min(Mbuffs[0][k], curramp);
		for (i = 1; i < NumMbuff; ++i)
			currnoisebin = min(currnoisebin, Mbuffs[i][k]);

		currnoisebin *= alpha;

		float g = max(lambda, 1-(currnoisebin/curramp));
		procframe[k] = rmul(g, procframe[k]);
	}

	
	ifft(FFTLEN, procframe);


fft(FFTLEN, procframe);
									
    static int MRotate_ctr = 0;

	if (MRotate_ctr == MrotateFramecount){

		MRotate_ctr = 0;

		//rotate Mbuffs
		float* rottemp = Mbuffs[NumMbuff-1];
		for (i = NumMbuff-1; i != 0; --i)
			Mbuffs[i] = Mbuffs[i-1];
		Mbuffs[0] = rottemp;

		//Init new mbuff
		clearM = 1;
	} else {
		MRotate_ctr++;
		clearM = 0;
	}

	for (k = 0; k < FFTLEN; ++k)
	{
		float curramp = cabs(procframe[k]); 

		//LPF curramp
		curramp = (1-kop1)*curramp + kop1*ampbinstate[k];
		ampbinstate[k] = curramp;

		float currnoisebin = clearM ? curramp : min(Mbuffs[0][k], curramp);
		Mbuffs[0][k] = currnoisebin;

		for (i = 1; i < NumMbuff; ++i)
			currnoisebin = min(currnoisebin, Mbuffs[i][k]);

		currnoisebin *= alpha;

		float g = max(lambda, 1-(currnoisebin/curramp));
		procframe[k] = rmul(g, procframe[k]);
	}

	
	ifft(FFTLEN, procframe);
    \end{lstlisting}
  \end{center}

\subsection{Notes} % (fold)
\label{sec:notes}
\begin{itemize}
	\item We tried matlab, and we did slightly better (in our opinion, elaborate!)
	\item Try to find some sort of research paper based method, becase of research paperness
	\item Nonlinear clipping: inspiration = skype: see if skype has some papers on it?
	\item Do voice vs not voice spectral regions/singature and shape a filter for voice frequencies.
	\item If time > something large: do eigenvoices (perhaps talk about them anyway)
	\item 

\end{itemize}
% section notes (end)

\end{document}